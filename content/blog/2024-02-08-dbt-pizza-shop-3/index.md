---
title: Data Build Tool (dbt) Pizza Shop Demo - Part 3 Modelling on BigQuery
date: 2024-02-08
draft: false
featured: true
comment: true
toc: true
reward: false
pinned: false
carousel: false
featuredImage: false
series:
  - DBT Pizza Shop Demo
categories:
  - Data Engineering
tags: 
  - Data Build Tool (DBT)
  - GCP
  - BigQuery
  - Python
authors:
  - JaehyeonKim
images: []
description: In this series, we discuss practical examples of data warehouse and lakehouse development where data transformation is performed by the data build tool (dbt) and ETL is managed by Apache Airflow. In Part 1, we developed a dbt project on PostgreSQL using fictional pizza shop data. At the end, the data sets are modelled by two SCD type 2 dimension tables and one transactional fact table. In this post, we create a new dbt project that targets Google BigQuery. While the dimension tables are kept by the same SCD type 2 approach, the fact table is denormalized using nested and repeated fields, which potentially can improve query performance by pre-joining corresponding dimension records.
---

In this series, we discuss practical examples of data warehouse and lakehouse development where data transformation is performed by the [data build tool (dbt)](https://docs.getdbt.com/docs/introduction) and ETL is managed by [Apache Airflow](https://airflow.apache.org/). In [Part 1](/blog/2024-01-18-dbt-pizza-shop-1), we developed a *dbt* project on PostgreSQL using fictional pizza shop data. At the end, the data sets are modelled by two [SCD type 2](https://en.wikipedia.org/wiki/Slowly_changing_dimension) dimension tables and one transactional fact table. In this post, we create a new *dbt* project that targets [Google BigQuery](https://cloud.google.com/bigquery). While the dimension tables are kept by the same SCD type 2 approach, the fact table is denormalized using [nested and repeated fields](https://cloud.google.com/bigquery/docs/best-practices-performance-nested), which potentially can improve query performance by pre-joining corresponding dimension records.

* [Part 1 Modelling on PostgreSQL](/blog/2024-01-18-dbt-pizza-shop-1)
* [Part 2 ETL on PostgreSQL via Airflow](/blog/2024-01-25-dbt-pizza-shop-2)
* [Part 3 Modelling on BigQuery](#) (this post)
* [Part 4 ETL on BigQuery via Airflow](/blog/2024-02-22-dbt-pizza-shop-4)
* [Part 5 Modelling on Amazon Athena](/blog/2024-03-07-dbt-pizza-shop-5)
* Part 6 ETL on Amazon Athena via Airflow

## Setup BigQuery

Google BigQuery is used in the post, and the source can be found in the [**GitHub repository**](https://github.com/jaehyeon-kim/general-demos/tree/master/dbt-bigquery-demo) of this post.

### Prepare Data

Fictional pizza shop data from [Building Real-Time Analytics Systems](https://www.oreilly.com/library/view/building-real-time-analytics/9781098138783/) is used in this post. There are three data sets - *products*, *users* and *orders*. The first two data sets are copied from the book's [GitHub repository](https://github.com/mneedham/real-time-analytics-book/tree/main/mysql/data) and saved into the *setup/data* folder. The last order data set is generated by the following Python script.

```python
# setup/generate_orders.py
import os
import csv
import dataclasses
import random
import json


@dataclasses.dataclass
class Order:
    user_id: int
    items: str

    @staticmethod
    def create():
        order_items = [
            {"product_id": id, "quantity": random.randint(1, 5)}
            for id in set(random.choices(range(1, 82), k=random.randint(1, 10)))
        ]
        return Order(
            user_id=random.randint(1, 10000),
            items=json.dumps([item for item in order_items]),
        )


if __name__ == "__main__":
    """
    Generate random orders given by the NUM_ORDERS environment variable.
        - orders.csv will be written to ./data folder
    
    Example:
        python generate_orders.py
        NUM_ORDERS=10000 python generate_orders.py
    """
    NUM_ORDERS = int(os.getenv("NUM_ORDERS", "20000"))
    CURRENT_DIR = os.path.dirname(os.path.realpath(__file__))
    orders = [Order.create() for _ in range(NUM_ORDERS)]

    filepath = os.path.join(CURRENT_DIR, "data", "orders.csv")
    if os.path.exists(filepath):
        os.remove(filepath)

    with open(os.path.join(CURRENT_DIR, "data", "orders.csv"), "w") as f:
        writer = csv.writer(f)
        writer.writerow(["user_id", "items"])
        for order in orders:
            writer.writerow(dataclasses.asdict(order).values())
```

Below shows sample order records generated by the script. It includes user ID and order items.

```txt
user_id,items
6845,"[{""product_id"": 52, ""quantity"": 4}, {""product_id"": 68, ""quantity"": 5}]"
6164,"[{""product_id"": 77, ""quantity"": 4}]"
9303,"[{""product_id"": 5, ""quantity"": 2}, {""product_id"": 71, ""quantity"": 3}, {""product_id"": 74, ""quantity"": 2}, {""product_id"": 10, ""quantity"": 5}, {""product_id"": 12, ""quantity"": 2}]"
```

The folder structure of source data sets and order generation script can be found below.

```bash
$ tree setup/ -P  "*.csv|generate*"
setup/
├── data
│   ├── orders.csv
│   ├── products.csv
│   └── users.csv
└── generate_orders.py
```

### Insert Source Data

The source data sets are inserted into staging tables using a Python script.

#### Create Stage Tables

A BigQuery [dataset](https://cloud.google.com/bigquery/docs/datasets-intro) named *pizza_shop* is created, and three staging tables are created as shown below.

```sql
-- setup/create_stage_tables.sql
DROP TABLE IF EXISTS pizza_shop.staging_users;
DROP TABLE IF EXISTS pizza_shop.staging_products;
DROP TABLE IF EXISTS pizza_shop.staging_orders;

CREATE TABLE pizza_shop.staging_users
(
    id INTEGER,
    first_name STRING,
    last_name STRING,
    email STRING,
    residence STRING,
    lat DECIMAL(10, 8),
    lon DECIMAL(10, 8),
    created_at DATETIME
);

CREATE TABLE pizza_shop.staging_products
(
    id INTEGER,
    name STRING,
    description STRING,
    price FLOAT64,
    category STRING,
    image STRING,
    created_at DATETIME
);

CREATE TABLE pizza_shop.staging_orders
(
    id INTEGER,
    user_id INTEGER,
    items JSON,
    created_at DATETIME
);
```

### Insert Records

The source data is inserted using the [Python Client for Google BigQuery](https://cloud.google.com/python/docs/reference/bigquery/latest). It is a simple process that reads records from the source data files as dictionary while adding incremental ID/creation datetime and inserts them using the client library. Note that a service account is used for authentication and its key file (*key.json*) is placed in the *sa_key* folder that exists in the same level of the script's parent folder - see below for the required folder structure.

```python
# setup/insert_records.py
import os
import csv
import datetime

from google.cloud import bigquery
from google.oauth2 import service_account


class QueryHelper:
    def __init__(self, current_dir: str = None):
        self.current_dir = current_dir or os.path.dirname(os.path.realpath(__file__))
        self.credentials = self.get_credentials()
        self.client = bigquery.Client(
            credentials=self.credentials, project=self.credentials.project_id
        )

    def get_credentials(self):
        # https://cloud.google.com/bigquery/docs/samples/bigquery-client-json-credentials#bigquery_client_json_credentials-python
        sa_key_path = os.path.join(
            os.path.dirname(self.current_dir), "sa_key", "key.json"
        )
        return service_account.Credentials.from_service_account_file(
            sa_key_path, scopes=["https://www.googleapis.com/auth/cloud-platform"]
        )

    def get_table(self, dataset_name: str, table_name: str):
        return self.client.get_table(
            f"{self.credentials.project_id}.{dataset_name}.{table_name}"
        )

    def insert_rows(self, dataset_name: str, table_name: str, records: list):
        table = self.get_table(dataset_name, table_name)
        errors = self.client.insert_rows_json(table, records)
        if len(errors) > 0:
            print(errors)
            raise RuntimeError("fails to insert records")


class DataHelper:
    def __init__(self, current_dir: str = None):
        self.current_dir = current_dir or os.path.dirname(os.path.realpath(__file__))

    def load_data(self, file_name: str):
        created_at = datetime.datetime.now().isoformat(timespec="seconds")
        records = []
        with open(os.path.join(self.current_dir, "data", file_name), mode="r") as f:
            rows = csv.DictReader(f)
            for ind, row in enumerate(rows):
                extras = {"id": ind + 1, "created_at": created_at}
                records.append({**extras, **row})
        return records


if __name__ == "__main__":
    dataset_name = os.getenv("DATASET_NAME", "pizza_shop")

    query_helper = QueryHelper()
    data_helper = DataHelper()
    print("inserting products...")
    products = data_helper.load_data("products.csv")
    query_helper.insert_rows(dataset_name, "staging_products", products)
    print("inserting users...")
    users = data_helper.load_data("users.csv")
    query_helper.insert_rows(dataset_name, "staging_users", users)
    print("inserting orders...")
    orders = data_helper.load_data("orders.csv")
    query_helper.insert_rows(dataset_name, "staging_orders", orders)
```

As mentioned, the key file (*key.json*) is located in the *sa_key* folder that exists in the same level of the script's parent folder. It is kept separately as it can be shared by the dbt project and Airflow scheduler as well.

```bash
$ tree sa_key/ && tree setup/ -P "insert_records.py|*.csv"
sa_key/
└── key.json

setup/
├── data
│   ├── orders.csv
│   ├── products.csv
│   └── users.csv
└── insert_records.py
```

## Setup DBT Project

A *dbt* project named *pizza_shop* is created using the *dbt-bigquery* package (*dbt-bigquery==1.7.4*). Specifically, it is created using the `dbt init` command, and it bootstraps the project in the *pizza_shop* folder as well as adds the project profile to the *dbt* profiles file. Note that the service account is used for authentication and the path of its key file is specified in the *keyfile* attribute. See [this page](https://docs.getdbt.com/docs/core/connect-data-platform/bigquery-setup) for details about how to set up BigQuery for a *dbt* project.

```yaml
# $HOME/.dbt/profiles.yml
pizza_shop:
  outputs:
    dev:
      type: bigquery
      method: service-account
      project: <project-id>
      dataset: pizza_shop
      threads: 4
      keyfile: <path-to-service-account-key-file>
      job_execution_timeout_seconds: 300
      job_retries: 1
      location: US
      priority: interactive
  target: dev
```

### Project Sources

Recall that three staging tables are created earlier, and they are used as sources of the project. Their details are kept in *sources.yml* to be referred easily in other models.

```yaml
# pizza_shop/models/sources.yml
version: 2

sources:
  - name: raw
    schema: pizza_shop
    tables:
      - name: users
        identifier: staging_users
      - name: products
        identifier: staging_products
      - name: orders
        identifier: staging_orders
```

Using the raw sources, three models are created by performing simple transformations such as adding [surrogate keys](https://docs.getdbt.com/terms/surrogate-key) using the *dbt_utils* package and changing column names. Note that, as the *products* and *users* dimension tables are kept by [Type 2 slowly changing dimension (SCD type 2)](https://en.wikipedia.org/wiki/Slowly_changing_dimension), the surrogate keys are used to uniquely identify relevant dimension records.

```sql
-- pizza_shop/models/src/src_products.sql
WITH raw_products AS (
  SELECT * FROM {{ source('raw', 'products') }}
)
SELECT
  {{ dbt_utils.generate_surrogate_key(['name', 'description', 'price', 'category', 'image']) }} as product_key,
  id AS product_id,
  name,
  description,
  price,
  category,
  image,
  created_at
FROM raw_products
```

```sql
-- pizza_shop/models/src/src_users.sql
WITH raw_users AS (
  SELECT * FROM {{ source('raw', 'users') }}
)
SELECT
  {{ dbt_utils.generate_surrogate_key(['first_name', 'last_name', 'email', 'residence', 'lat', 'lon']) }} as user_key,
  id AS user_id,
  first_name,
  last_name,
  email,
  residence,
  lat AS latitude,
  lon AS longitude,
  created_at
FROM raw_users
```

```sql
-- pizza_shop/models/src/src_orders.sql
WITH raw_orders AS (
  SELECT * FROM {{ source('raw', 'orders') }}
)
SELECT
  id AS order_id,
  user_id,
  items,
  created_at
FROM raw_orders
```

### Data Modelling

For SCD type 2, the dimension tables are materialized as *table* and two additional columns are included - *valid_from* and *valid_to*. The extra columns are for setting up a time range where a record is applicable, and they are used to map a relevant record in the fact table when there are multiple dimension records according to the same natural key. Note that SCD type 2 tables can also be maintained by [*dbt* snapshots](https://docs.getdbt.com/docs/build/snapshots).

```sql
-- pizza_shop/models/dim/dim_products.sql
{{
  config(
    materialized = 'table',
    )
}}
WITH src_products AS (
  SELECT * FROM {{ ref('src_products') }}
)
SELECT
    *, 
    created_at AS valid_from,
    COALESCE(
      LEAD(created_at, 1) OVER (PARTITION BY product_id ORDER BY created_at), 
      CAST('2199-12-31' AS DATETIME)
    ) AS valid_to
FROM src_products
```

```sql
-- pizza_shop/models/dim/dim_users.sql
{{
  config(
    materialized = 'table',
    )
}}
WITH src_users AS (
  SELECT * FROM {{ ref('src_users') }}
)
SELECT
    *, 
    created_at AS valid_from,
    COALESCE(
      LEAD(created_at, 1) OVER (PARTITION BY user_id ORDER BY created_at), 
      CAST('2199-12-31' AS DATETIME)
    ) AS valid_to
FROM src_users
```

The transactional fact table is materialized as *incremental* so that only new records are appended. Also, it is created as a partitioned table for improving query performance by adding date filter. Finally, the user and order items records are pre-joined from the relevant dimension tables. See below for details about how this fact table is structured in *BigQuery*.

```sql
-- pizza_shop/models/fct/fct_orders.sql
{{
  config(
    materialized = 'incremental',
    partition_by = {
      'field': 'order_date',
      'data_type': 'date',
      'granularity': 'day',
      'time_ingestion_partitioning': true
    })
}}
WITH dim_products AS (
  SELECT * FROM {{ ref('dim_products') }}
), dim_users AS (
  SELECT * FROM {{ ref('dim_users') }}
), expanded_orders AS (
  SELECT 
    order_id,
    user_id,
    CAST(JSON_EXTRACT_SCALAR(json , '$.product_id') AS INTEGER) AS product_id,
    CAST(JSON_EXTRACT_SCALAR(json , '$.quantity') AS INTEGER) AS quantity,
    created_at
  FROM {{ ref('src_orders') }} AS t,
    UNNEST(JSON_EXTRACT_ARRAY(t.items , '$')) AS json
)
SELECT
  o.order_id,
  ARRAY_AGG(
    STRUCT(p.product_key AS key, o.product_id AS id, p.name, p.price, o.quantity, p.description, p.category, p.image)
  ) as product,
  STRUCT(u.user_key AS key, o.user_id AS id, u.first_name, u.last_name, u.email, u.residence, u.latitude, u.longitude) AS user,
  o.created_at,
  EXTRACT(DATE FROM o.created_at) AS order_date
FROM expanded_orders o
JOIN dim_products p 
  ON o.product_id = p.product_id
    AND o.created_at >= p.valid_from
    AND o.created_at < p.valid_to
JOIN dim_users u 
  ON o.user_id = u.user_id
    AND o.created_at >= u.valid_from
    AND o.created_at < u.valid_to
{% if is_incremental() %}
  WHERE o.created_at > (SELECT max(created_at) from {{ this }})
{% endif %}
GROUP BY 
  o.order_id, 
  u.user_key, 
  o.user_id, 
  u.first_name, 
  u.last_name, 
  u.email, 
  u.residence, 
  u.latitude, 
  u.longitude, 
  o.created_at
```

We can keep the final models in a separate YAML file for testing and enhanced documentation.

```yaml
# pizza_shop/models/schema.yml
version: 2

models:
  - name: dim_products
    description: Products table, which is converted into SCD type 2
    columns:
      - name: product_key
        description: |
          Primary key of the table
          Surrogate key, which is generated by md5 hash using the following columns
            - name, description, price, category, image
        tests:
          - not_null
          - unique
      - name: product_id
        description: Natural key of products
      - name: name
        description: Porduct name
      - name: description
        description: Product description
      - name: price
        description: Product price
      - name: category
        description: Product category
      - name: image
        description: Product image
      - name: created_at
        description: Timestamp when the record is loaded
      - name: valid_from
        description: Effective start timestamp of the corresponding record (inclusive)
      - name: valid_to
        description: Effective end timestamp of the corresponding record (exclusive)
  - name: dim_users
    description: Users table, which is converted into SCD type 2
    columns:
      - name: user_key
        description: |
          Primary key of the table
          Surrogate key, which is generated by md5 hash using the following columns
            - first_name, last_name, email, residence, lat, lon
        tests:
          - not_null
          - unique
      - name: user_id
        description: Natural key of users
      - name: first_name
        description: First name
      - name: last_name
        description: Last name
      - name: email
        description: Email address
      - name: residence
        description: User address
      - name: latitude
        description: Latitude of user address
      - name: longitude
        description: Longitude of user address
      - name: created_at
        description: Timestamp when the record is loaded
      - name: valid_from
        description: Effective start timestamp of the corresponding record (inclusive)
      - name: valid_to
        description: Effective end timestamp of the corresponding record (exclusive)
  - name: fct_orders
    description: Orders fact table. Order items are exploded into rows
    columns:
      - name: order_id
        description: Natural key of orders
      - name: product
        description: |
          Array of products in an order.
          A product is an array of struct where the following attributes are pre-joined from the dim_products table:
            key (product_key), id (product_id), name, price, quantity, description, category, and image
      - name: user
        description: |
          A struct where the following attributes are pre-joined from the dim_users table:
            key (user_key), id (user_id), first_name, last_name, email, residence, latitude, and longitude
      - name: created_at
        description: Timestamp when the record is loaded
```

The project can be executed using the `dbt run` command as shown below.

```bash
$ dbt run
23:06:05  Running with dbt=1.7.7
23:06:05  Registered adapter: bigquery=1.7.4
23:06:05  Found 6 models, 4 tests, 3 sources, 0 exposures, 0 metrics, 568 macros, 0 groups, 0 semantic models
23:06:05  
23:06:07  Concurrency: 4 threads (target='dev')
23:06:07  
23:06:07  1 of 6 START sql view model pizza_shop.src_orders .............................. [RUN]
23:06:07  2 of 6 START sql view model pizza_shop.src_products ............................ [RUN]
23:06:07  3 of 6 START sql view model pizza_shop.src_users ............................... [RUN]
23:06:08  1 of 6 OK created sql view model pizza_shop.src_orders ......................... [CREATE VIEW (0 processed) in 1.65s]
23:06:09  3 of 6 OK created sql view model pizza_shop.src_users .......................... [CREATE VIEW (0 processed) in 1.93s]
23:06:09  2 of 6 OK created sql view model pizza_shop.src_products ....................... [CREATE VIEW (0 processed) in 1.93s]
23:06:09  4 of 6 START sql table model pizza_shop.dim_users .............................. [RUN]
23:06:09  5 of 6 START sql table model pizza_shop.dim_products ........................... [RUN]
23:06:14  5 of 6 OK created sql table model pizza_shop.dim_products ...................... [CREATE TABLE (81.0 rows, 0 processed) in 5.21s]
23:06:14  4 of 6 OK created sql table model pizza_shop.dim_users ......................... [CREATE TABLE (10.0k rows, 0 processed) in 5.21s]
23:06:14  6 of 6 START sql incremental model pizza_shop.fct_orders ....................... [RUN]
23:06:25  6 of 6 OK created sql incremental model pizza_shop.fct_orders .................. [INSERT (20.0k rows, 1.6 MiB processed) in 11.23s]
23:06:25  
23:06:25  Finished running 3 view models, 2 table models, 1 incremental model in 0 hours 0 minutes and 19.92 seconds (19.92s).
23:06:25  
23:06:25  Completed successfully
23:06:25  
23:06:25  Done. PASS=6 WARN=0 ERROR=0 SKIP=0 TOTAL=6
```

Also, the project can be tested using the `dbt test` command.

```bash
$ dbt test
23:06:53  Running with dbt=1.7.7
23:06:54  Registered adapter: bigquery=1.7.4
23:06:54  Found 6 models, 4 tests, 3 sources, 0 exposures, 0 metrics, 568 macros, 0 groups, 0 semantic models
23:06:54  
23:06:55  Concurrency: 4 threads (target='dev')
23:06:55  
23:06:55  1 of 4 START test not_null_dim_products_product_key ............................ [RUN]
23:06:55  2 of 4 START test not_null_dim_users_user_key .................................. [RUN]
23:06:55  3 of 4 START test unique_dim_products_product_key .............................. [RUN]
23:06:55  4 of 4 START test unique_dim_users_user_key .................................... [RUN]
23:06:57  2 of 4 PASS not_null_dim_users_user_key ........................................ [PASS in 2.27s]
23:06:57  1 of 4 PASS not_null_dim_products_product_key .................................. [PASS in 2.40s]
23:06:57  3 of 4 PASS unique_dim_products_product_key .................................... [PASS in 2.42s]
23:06:57  4 of 4 PASS unique_dim_users_user_key .......................................... [PASS in 2.51s]
23:06:57  
23:06:57  Finished running 4 tests in 0 hours 0 minutes and 3.23 seconds (3.23s).
23:06:57  
23:06:57  Completed successfully
23:06:57  
23:06:57  Done. PASS=4 WARN=0 ERROR=0 SKIP=0 TOTAL=4
```

#### Fact Table Structure

The schema of the fact table can be found below. Both the *product* and *user* fields are marked as the *RECORD* type as they are *struct*s (containers of fields). Also, the mode of the *product* is indicated as *REPEATED*, which means it is an array.

![](fct-orders-schema.png#center)

In the query result view, non-array fields are not repeated, and a row is split to fill each of the array items.

![](fct-orders-query-01.png#center)

We can use the [*UNNEST*](https://cloud.google.com/bigquery/docs/arrays) operator if we need to convert the elements of an array into rows as shown below.

![](fct-orders-query-02.png#center)

## Update Records

Although we will discuss ETL orchestration with Apache Airflow in the next post, here I illustrate how the dimension and fact tables change when records are updated.

### Product

First, a new record is inserted into the *staging_products* table, and the price is set to increase by 10.

```sql
-- // update a product record
INSERT INTO pizza_shop.staging_products (id, name, description, price, category, image, created_at)
    SELECT 1, name, description, price + 10, category, image, CURRENT_DATETIME('Australia/Sydney')
    FROM pizza_shop.staging_products
    WHERE id = 1;

SELECT id, name, price, category, created_at 
FROM pizza_shop.staging_products
WHERE id = 1
ORDER BY created_at;

i  dname                             price  category    created_at
1  Moroccan Spice Pasta Pizza - Veg  335.0  veg pizzas  2024-02-04T09:50:05
1  Moroccan Spice Pasta Pizza - Veg  345.0  veg pizzas  2024-02-04T10:15:30.227352
```

When we execute the `dbt run` command again, we see the corresponding dimension table reflects the change by adding a new record and updating *valid_from* and *valid_to* columns accordingly. With this change, any later order record that has this product should be mapped into the new product record.

```sql
SELECT product_key, price, created_at, valid_from, valid_to 
FROM pizza_shop.dim_products 
WHERE product_id = 1
ORDER BY created_at;

product_key                       price  created_at                  valid_from                  valid_to
a8c5f8c082bcf52a164f2eccf2b493f6  335.0  2024-02-04T09:50:05         2024-02-04T09:50:05         2024-02-04T10:15:30.227352
c995d7e1ec035da116c0f37e6284d1d5  345.0  2024-02-04T10:15:30.227352  2024-02-04T10:15:30.227352  2199-12-31T00:00:00
```

### User

Also, a new record is inserted into the *staging_users* table while modifying the email address.

```sql
-- // update a user record
INSERT INTO pizza_shop.staging_users (id, first_name, last_name, email, residence, lat, lon, created_at)
    SELECT 1, first_name, last_name, 'john.doe@example.com', residence, lat, lon, CURRENT_DATETIME('Australia/Sydney')
    FROM pizza_shop.staging_users
    WHERE id = 1;

SELECT id, first_name, last_name, email, created_at 
FROM pizza_shop.staging_users
WHERE id = 1
ORDER BY created_at;

id  first_name  last_name  email                       created_at
1   Kismat      Shroff     drishyamallick@hotmail.com  2024-02-04T09:50:07
1   Kismat      Shroff     john.doe@example.com        2024-02-04T10:17:48.340304
```

Again the corresponding dimension table reflects the change by adding a new record and updating *valid_from* and *valid_to* columns accordingly.

```sql
SELECT user_key, email, valid_from, valid_to 
FROM pizza_shop.dim_users 
WHERE user_id = 1
ORDER BY created_at;

user_key                          email                       valid_from                  valid_to
8adf084f4ea4b01d4863da22c61873de  drishyamallick@hotmail.com  2024-02-04T09:50:07         2024-02-04T10:17:48.340304
65e019d6a1fa0ca03e520b49928ee95b  john.doe@example.com        2024-02-04T10:17:48.340304  2199-12-31T00:00:00
```

### Order

We insert a new order record that has two items where the IDs of the first and second products are 1 and 2 respectively. In this example, we expect the first product maps to the updated product record while the record of the second product remains the same. We can check it by querying the new order record together with an existing record that has corresponding products. As expected, the query result shows the product record is updated only in the new order record.

```sql
-- // add an order record
INSERT INTO pizza_shop.staging_orders(id, user_id, items, created_at)
VALUES (
  20001, 
  1,
  JSON_ARRAY(JSON '{"product_id": 1, "quantity": 2}', JSON '{"product_id": 2, "quantity": 3}'), 
  CURRENT_DATETIME('Australia/Sydney')
);

SELECT o.order_id, p.key, p.id, p.price, p.quantity, o.created_at
FROM `pizza_shop.fct_orders` AS o,
  UNNEST(o.product) AS p
WHERE o.order_id in (11146, 20001) AND p.id IN (1, 2)
ORDER BY order_id;

order_id  key                                id  price  quantity  created_at
11146     * a8c5f8c082bcf52a164f2eccf2b493f6  1  335.0         1  2024-02-04T09:50:10
11146     8dd51b3981692c787baa9d4335f15345    2   60.0         2  2024-02-04T09:50:10
20001     * c995d7e1ec035da116c0f37e6284d1d5  1  345.0         2  2024-02-04T10:30:19.667473
20001     8dd51b3981692c787baa9d4335f15345    2   60.0         3  2024-02-04T10:30:19.667473
```

## Summary

In this series, we discuss practical examples of data warehouse and lakehouse development where data transformation is performed by the data build tool (dbt) and ETL is managed by Apache Airflow. In this post, we developed a dbt project on Google BigQuery using fictional pizza shop data. Two SCD type 2 dimension tables and a single transaction tables were modelled on a dbt project. The transaction table was denormalized using nested and repeated fields, which potentially can improve query performance by pre-joining corresponding dimension records. Finally, impacts of record updates were discussed in detail.