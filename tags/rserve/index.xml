<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Rserve on Jaehyeon Kim</title><link>https://jaehyeon.me/tags/rserve/</link><description>Recent content in Rserve on Jaehyeon Kim</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>Copyright Â© 2023-2024 Jaehyeon Kim. All Rights Reserved.</copyright><lastBuildDate>Fri, 29 Nov 2019 00:00:00 +0000</lastBuildDate><atom:link href="https://jaehyeon.me/tags/rserve/index.xml" rel="self" type="application/rss+xml"/><item><title>Dynamic Routing and Centralized Auth with Traefik, Python and R Example</title><link>https://jaehyeon.me/blog/2019-11-29-traefik-example/</link><pubDate>Fri, 29 Nov 2019 00:00:00 +0000</pubDate><guid>https://jaehyeon.me/blog/2019-11-29-traefik-example/</guid><description><![CDATA[<p><a href="https://kubernetes.io/docs/concepts/services-networking/ingress/" target="_blank" rel="noopener noreferrer">Ingress<i class="fas fa-external-link-square-alt ms-1"></i></a> in <a href="https://kubernetes.io/" target="_blank" rel="noopener noreferrer">Kubernetes<i class="fas fa-external-link-square-alt ms-1"></i></a> exposes HTTP and HTTPS routes from outside the cluster to services within the cluster. By setting rules, it routes requests to appropriate services (precisely requests are sent to individual <a href="https://kubernetes.io/docs/concepts/workloads/pods/pod-overview/" target="_blank" rel="noopener noreferrer">Pods<i class="fas fa-external-link-square-alt ms-1"></i></a> by <a href="https://kubernetes.io/docs/concepts/services-networking/ingress-controllers/" target="_blank" rel="noopener noreferrer">Ingress Controller<i class="fas fa-external-link-square-alt ms-1"></i></a>). Rules can be set up dynamically and I find it&rsquo;s more efficient compared to traditional <a href="https://en.wikipedia.org/wiki/Reverse_proxy" target="_blank" rel="noopener noreferrer">reverse proxy<i class="fas fa-external-link-square-alt ms-1"></i></a>.</p>
<p><a href="https://docs.traefik.io/v1.7/" target="_blank" rel="noopener noreferrer">Traefik<i class="fas fa-external-link-square-alt ms-1"></i></a> is a modern HTTP reverse proxy and load balancer and it can be used as a <em>Kubernetes</em> <em>Ingress Controller</em>. Moreover it supports other <a href="https://docs.traefik.io/providers/overview/" target="_blank" rel="noopener noreferrer">providers<i class="fas fa-external-link-square-alt ms-1"></i></a>, which are existing infrastructure components such as orchestrators, container engines, cloud providers, or key-value stores. To name a few, Docker, Kubernetes, AWS ECS, AWS DynamoDB and Consul are <a href="https://docs.traefik.io/v1.7/" target="_blank" rel="noopener noreferrer">supported providers<i class="fas fa-external-link-square-alt ms-1"></i></a>. With <em>Traefik</em>, it is possible to configure routing dynamically. Another interesting feature is <a href="https://docs.traefik.io/v1.7/configuration/entrypoints/#forward-authentication" target="_blank" rel="noopener noreferrer">Forward Authentication<i class="fas fa-external-link-square-alt ms-1"></i></a> where authentication can be handled by an external service. In this post, it&rsquo;ll be demonstrated how <em>path-based</em> routing can be set up by <em>Traefik with Docker</em>. Also a centralized authentication will be illustrated with the <em>Forward Authentication</em> feature of <em>Traefik</em>.</p>]]></description><enclosure url="https://jaehyeon.me/blog/2019-11-29-traefik-example/featured.png" length="139790" type="image/png"/></item><item><title>Distributed Task Queue with Python and R Example</title><link>https://jaehyeon.me/blog/2019-11-15-task-queue/</link><pubDate>Fri, 15 Nov 2019 00:00:00 +0000</pubDate><guid>https://jaehyeon.me/blog/2019-11-15-task-queue/</guid><description><![CDATA[<p>While I&rsquo;m looking into <a href="https://airflow.apache.org/" target="_blank" rel="noopener noreferrer">Apache Airflow<i class="fas fa-external-link-square-alt ms-1"></i></a>, a workflow management tool, I thought it would be beneficial to get some understanding of how <a href="http://www.celeryproject.org/" target="_blank" rel="noopener noreferrer">Celery<i class="fas fa-external-link-square-alt ms-1"></i></a> works. To do so, I built a simple web service that sends tasks to Celery workers and collects the results from them. <a href="https://fastapi.tiangolo.com/" target="_blank" rel="noopener noreferrer">FastAPI<i class="fas fa-external-link-square-alt ms-1"></i></a> is used for developing the web service and <a href="https://redis.io/" target="_blank" rel="noopener noreferrer">Redis<i class="fas fa-external-link-square-alt ms-1"></i></a> is used for the message broker and result backend. During the development, I thought it would be possible to implement similar functionality in R with <a href="https://www.rforge.net/Rserve/" target="_blank" rel="noopener noreferrer">Rserve<i class="fas fa-external-link-square-alt ms-1"></i></a>. Therefore a Rserve worker is added as an example as well. Coupling a web service with distributed task queue is beneficial on its own as it helps the service be more responsive by offloading heavyweight and long running processes to task workers.</p>]]></description><enclosure url="https://jaehyeon.me/blog/2019-11-15-task-queue/featured.png" length="51615" type="image/png"/></item><item><title>Linux Dev Environment on Windows</title><link>https://jaehyeon.me/blog/2019-11-01-linux-on-windows/</link><pubDate>Fri, 01 Nov 2019 00:00:00 +0000</pubDate><guid>https://jaehyeon.me/blog/2019-11-01-linux-on-windows/</guid><description><![CDATA[<p>I use Linux containers a lot for development. Having Windows computers at home and work, I used to use Linux VMs on VirtualBox or VMWare Workstation. It&rsquo;s not a bad option but it requires a lot of resources. Recently, after my home computer was updated, I was not able to start my hypervisor anymore. Also I didn&rsquo;t like huge resource consumption of it so that I began to look for a different development environment. A while ago, I played with <a href="https://docs.microsoft.com/en-us/windows/wsl/about" target="_blank" rel="noopener noreferrer">Windows Subsystem for Linux (WSL)<i class="fas fa-external-link-square-alt ms-1"></i></a> and it was alright. Also <a href="https://code.visualstudio.com/" target="_blank" rel="noopener noreferrer">Visual Studio Code (VSCode)<i class="fas fa-external-link-square-alt ms-1"></i></a>, <em>my favourite editor</em>, now supports <a href="https://code.visualstudio.com/docs/remote/remote-overview" target="_blank" rel="noopener noreferrer">remote development<i class="fas fa-external-link-square-alt ms-1"></i></a>. Initially I thought I would be able to create a new development environment with WSL and <a href="https://docs.docker.com/docker-for-windows/install/" target="_blank" rel="noopener noreferrer">Docker for Windows<i class="fas fa-external-link-square-alt ms-1"></i></a>. However it was until I tried a bigger app with <a href="https://docs.docker.com/compose/" target="_blank" rel="noopener noreferrer">Docker Compose<i class="fas fa-external-link-square-alt ms-1"></i></a> that Docker for Windows has a number of issues especially when containers are started by Docker Compose in WSL. I didn&rsquo;t like to spend too much time on fixing those issues as I concerned those might not be the only ones. Then I decided to install a Linux VM on <a href="https://docs.microsoft.com/en-us/virtualization/hyper-v-on-windows/about/" target="_blank" rel="noopener noreferrer">Hyper-V<i class="fas fa-external-link-square-alt ms-1"></i></a>. Luckly VSCode also supports a remote VM via SSH.</p>]]></description><enclosure url="https://jaehyeon.me/blog/2019-11-01-linux-on-windows/featured.png" length="187978" type="image/png"/></item><item><title>API Development with R Part II</title><link>https://jaehyeon.me/blog/2017-11-19-api-development-with-r-2/</link><pubDate>Sun, 19 Nov 2017 00:00:00 +0000</pubDate><guid>https://jaehyeon.me/blog/2017-11-19-api-development-with-r-2/</guid><description><![CDATA[<p>In <a href="/blog/2017-11-18-api-development-with-r-1">Part I</a>, it is discussed how to serve an R function with <em>plumber</em>, <em>Rserve</em> and <em>rApache</em>. In this post, the APIs are deployed in a Docker container and, after showing example requests, their performance is compared. The <a href="https://hub.docker.com/r/rocker/r-ver/" target="_blank" rel="noopener noreferrer">rocker/r-ver:3.4<i class="fas fa-external-link-square-alt ms-1"></i></a> is used as the base image and each of the APIs is added to it. For simplicity, the APIs are served by <a href="http://supervisord.org/" target="_blank" rel="noopener noreferrer">Supervisor<i class="fas fa-external-link-square-alt ms-1"></i></a>. For performance testing, <a href="https://locust.io/" target="_blank" rel="noopener noreferrer">Locust<i class="fas fa-external-link-square-alt ms-1"></i></a> is used. The source of this post can be found in this <a href="https://github.com/jaehyeon-kim/r-api-demo" target="_blank" rel="noopener noreferrer"><strong>GitHub repository</strong><i class="fas fa-external-link-square-alt ms-1"></i></a>.</p>]]></description><enclosure url="https://jaehyeon.me/blog/2017-11-19-api-development-with-r-2/featured.png" length="367256" type="image/png"/></item><item><title>API Development with R Part I</title><link>https://jaehyeon.me/blog/2017-11-18-api-development-with-r-1/</link><pubDate>Sat, 18 Nov 2017 00:00:00 +0000</pubDate><guid>https://jaehyeon.me/blog/2017-11-18-api-development-with-r-1/</guid><description><![CDATA[<p>API is an effective way of distributing analysis outputs to external clients. When it comes to API development with R, however, there are not many choices. Probably development would be made with <a href="https://github.com/trestletech/plumber" target="_blank" rel="noopener noreferrer">plumber<i class="fas fa-external-link-square-alt ms-1"></i></a>, <a href="https://www.rforge.net/Rserve/" target="_blank" rel="noopener noreferrer">Rserve<i class="fas fa-external-link-square-alt ms-1"></i></a>, <a href="http://rapache.net/" target="_blank" rel="noopener noreferrer">rApache<i class="fas fa-external-link-square-alt ms-1"></i></a> or <a href="https://www.opencpu.org/" target="_blank" rel="noopener noreferrer">OpenCPU<i class="fas fa-external-link-square-alt ms-1"></i></a> if a client or bridge layer to R is not considered.</p>
<p>This is 2 part series in relation to <em>API development with R</em>. In this post, serving an R function with <em>plumber</em>, <em>Rserve</em> and <em>rApache</em> is discussed. <em>OpenCPU</em> is not discussed partly because it could be overkill for API. Also its performance may be similar to <em>rApache</em> with <a href="http://httpd.apache.org/docs/2.2/mod/prefork.html" target="_blank" rel="noopener noreferrer">Prefork Multi-Processing Module<i class="fas fa-external-link-square-alt ms-1"></i></a> enabled. Then deploying the APIs in a Docker container, making example HTTP requests and their performance will be discussed in <a href="/blog/2015-02-08-tree-based-methods-2">Part II</a>.</p>]]></description><enclosure url="https://jaehyeon.me/blog/2017-11-18-api-development-with-r-1/featured.png" length="367256" type="image/png"/></item></channel></rss>